namespace SpaceEngineers.Core.CompositionRoot.Implementations
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Linq;
    using System.Reflection;
    using Api.Abstractions;
    using AutoRegistration.Api.Attributes;
    using Basics;
    using Basics.EqualityComparers;

    [SuppressMessage("Analysis", "SA1124", Justification = "Readability")]
    [ManuallyRegisteredComponent("Is created manually and implicitly during DependencyContainer initialization")]
    internal class TypeProvider : ITypeProvider
    {
        private static readonly string[] ExcludedTypes =
        {
            "<>f",
            "<>c",
            "d__",
            "<PrivateImplementationDetails>",
            "AutoGeneratedProgram",
            "Xunit",
            "System.Runtime.CompilerServices",
            "Microsoft.CodeAnalysis"
        };

        [SuppressMessage("Analysis", "SA1011", Justification = "space between square brackets and nullable symbol")]
        private static Assembly[]? _rootAssemblies;

        private readonly HashSet<string> _ourTypesCache;

        [Obsolete("Use factory methods instead")]
        public TypeProvider(IReadOnlyCollection<Assembly> allAssemblies,
                            IReadOnlyCollection<Assembly> rootAssemblies,
                            IReadOnlyCollection<Assembly> excludedAssemblies,
                            IReadOnlyCollection<string> excludedNamespaces)
        {
            AllLoadedAssemblies = allAssemblies
                .Union(rootAssemblies)
                .Distinct(new AssemblyByNameEqualityComparer())
                .Where(a => !a.IsDynamic)
                .ToList();

            AllLoadedTypes = AllLoadedAssemblies
                .SelectMany(a => a.GetTypes())
                .ToList();

            TypeCache = AllLoadedAssemblies
                .ToDictionary(assembly => assembly.GetName().Name,
                    assembly => (IReadOnlyDictionary<string, Type>)assembly.GetTypes().ToDictionary(type => type.FullName));

            var isOurReference = AssembliesExtensions.IsOurReference(AllLoadedAssemblies, rootAssemblies);

            OurAssemblies = AllLoadedAssemblies
                .Where(a => !excludedAssemblies.Contains(a))
                .Where(isOurReference)
                .ToList();

            OurTypes = OurAssemblies
                .SelectMany(ExtractOurTypes)
                .Where(t => !excludedNamespaces.Contains(t.Namespace, StringComparer.OrdinalIgnoreCase))
                .ToList();

            _ourTypesCache = new HashSet<string>(OurTypes.Select(type => type.FullName));
        }

        #region ITypeProvider

        public IReadOnlyCollection<Assembly> AllLoadedAssemblies { get; }

        public IReadOnlyCollection<Type> AllLoadedTypes { get; }

        public IReadOnlyCollection<Assembly> OurAssemblies { get; }

        public IReadOnlyCollection<Type> OurTypes { get; }

        public IReadOnlyDictionary<string, IReadOnlyDictionary<string, Type>> TypeCache { get; }

        public bool IsOurType(Type type)
        {
            return _ourTypesCache.Contains(type.FullName);
        }

        #endregion

        #region Creation

        internal static ITypeProvider CreateBoundedAbove(
            IReadOnlyCollection<Assembly> assemblies)
        {
            return CreateBoundedAbove(
                assemblies,
                Array.Empty<Assembly>(),
                Array.Empty<string>());
        }

        internal static ITypeProvider CreateBoundedAbove(
            IReadOnlyCollection<Assembly> assemblies,
            IReadOnlyCollection<Assembly> excludedAssemblies,
            IReadOnlyCollection<string> excludedNamespaces)
        {
            var belowAssemblies = assemblies
                .SelectMany(assembly => AssembliesExtensions.AllAssembliesFromCurrentDomain().Below(assembly))
                .Distinct()
                .ToArray();

            return CreateExactlyBounded(
                belowAssemblies,
                excludedAssemblies,
                excludedNamespaces);
        }

        internal static ITypeProvider CreateExactlyBounded(
            IReadOnlyCollection<Assembly> allAssemblies)
        {
            return CreateExactlyBounded(
                allAssemblies,
                Array.Empty<Assembly>(),
                Array.Empty<string>());
        }

        internal static ITypeProvider CreateExactlyBounded(
            IReadOnlyCollection<Assembly> allAssemblies,
            IReadOnlyCollection<Assembly> excludedAssemblies,
            IReadOnlyCollection<string> excludedNamespaces)
        {
            #pragma warning disable 618

            return new TypeProvider(
                allAssemblies,
                RootAssemblies(),
                excludedAssemblies,
                excludedNamespaces);

            #pragma warning restore 618
        }

        #endregion

        private static IEnumerable<Type> ExtractOurTypes(Assembly assembly)
        {
            return assembly
                .GetTypes()
                .Where(t => t.FullName != null
                            && ExcludedTypes.All(mask => !t.FullName.Contains(mask, StringComparison.Ordinal)));
        }

        private static Assembly[] RootAssemblies()
        {
            _rootAssemblies ??= InitRootAssemblies();
            return _rootAssemblies;

            static Assembly[] InitRootAssemblies()
            {
                return new[]
                {
                    AssembliesExtensions.FindRequiredAssembly(AssembliesExtensions.BuildName(nameof(SpaceEngineers), nameof(Core), nameof(Core.Basics))),
                    AssembliesExtensions.FindRequiredAssembly(AssembliesExtensions.BuildName(nameof(SpaceEngineers), nameof(Core), nameof(Core.AutoRegistration), nameof(Core.AutoRegistration.Api))),
                    AssembliesExtensions.FindRequiredAssembly(AssembliesExtensions.BuildName(nameof(SpaceEngineers), nameof(Core), nameof(Core.CompositionRoot), nameof(Core.CompositionRoot.Api))),
                    AssembliesExtensions.FindRequiredAssembly(AssembliesExtensions.BuildName(nameof(SpaceEngineers), nameof(Core), nameof(Core.CompositionRoot))),
                };
            }
        }
    }
}