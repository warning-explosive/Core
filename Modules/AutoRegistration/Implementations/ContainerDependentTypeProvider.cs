namespace SpaceEngineers.Core.AutoRegistration.Implementations
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using AutoWiringApi.Attributes;
    using AutoWiringApi.Services;
    using Basics.EqualityComparers;

    [ManualRegistration]
    internal class ContainerDependentTypeProvider : ITypeProvider
    {
        private static readonly string[] ExcludedAssemblies =
        {
            nameof(System),
            nameof(Microsoft),
            "Windows",
        };

        private static readonly string[] ExcludedTypes =
        {
            "<>f",
            "<>c",
            "d__",
            "<PrivateImplementationDetails>",
            "AutoGeneratedProgram",
            "Xunit",
            "System.Runtime.CompilerServices",
            "Microsoft.CodeAnalysis",
        };

        private readonly HashSet<string> _ourTypesCache;

        public ContainerDependentTypeProvider(Assembly[] assemblies, Assembly[] rootAssemblies)
        {
            AllLoadedAssemblies = assemblies.Where(a => !a.IsDynamic).ToList();
            AllLoadedTypes = AllLoadedAssemblies.SelectMany(a => a.GetTypes()).ToList();
            TypeCache = AllLoadedAssemblies
                       .ToDictionary(assembly => assembly.GetName().Name,
                                     assembly => (IReadOnlyDictionary<string, Type>)assembly.GetTypes().ToDictionary(type => type.FullName));

            var loadedAssembliesDict = AllLoadedAssemblies.Distinct(new AssemblyByNameEqualityComparer()).ToDictionary(a => a.GetName().FullName);
            var rootAssembliesDict = rootAssemblies.ToDictionary(a => a.GetName().FullName, a => a);
            var visited = rootAssemblies.ToDictionary(root => root.GetName().FullName, _ => true);

            OurAssemblies = loadedAssembliesDict
                           .Except(rootAssembliesDict)
                           .Select(pair => pair.Value)
                           .Where(a => IsOurReference(a, loadedAssembliesDict, visited))
                           .Concat(rootAssemblies)
                           .ToList();

            OurTypes = OurAssemblies
                      .SelectMany(ExtractOurTypes)
                      .ToList();

            _ourTypesCache = new HashSet<string>(OurTypes.Select(type => type.FullName));
        }

        public IReadOnlyCollection<Assembly> AllLoadedAssemblies { get; }

        public IReadOnlyCollection<Type> AllLoadedTypes { get; }

        public IReadOnlyCollection<Assembly> OurAssemblies { get; }

        public IReadOnlyCollection<Type> OurTypes { get; }

        public IReadOnlyDictionary<string, IReadOnlyDictionary<string, Type>> TypeCache { get; }

        public bool IsOurType(Type type)
        {
            return _ourTypesCache.Contains(type.FullName);
        }

        private bool IsOurReference(Assembly assembly, IReadOnlyDictionary<string, Assembly> loadedAssemblies, IDictionary<string, bool> visited)
        {
            var exclusiveReferences = assembly.GetReferencedAssemblies();
            var isReferencedDirectly = exclusiveReferences.Any(a => visited.ContainsKey(a.FullName) && visited[a.FullName]);
            var key = assembly.GetName().FullName;

            if (isReferencedDirectly)
            {
                visited[key] = true;
                return true;
            }

            var isIndirectlyReferenced = exclusiveReferences
                .Where(unknownReference => !visited.ContainsKey(unknownReference.FullName)
                                        && ExcludedAssemblies.All(ex => !unknownReference.FullName.StartsWith(ex, StringComparison.InvariantCultureIgnoreCase)))
                .Any(unknownReference => loadedAssemblies.TryGetValue(unknownReference.FullName, out var unknownAssembly)
                                         && IsOurReference(unknownAssembly, loadedAssemblies, visited));

            visited[key] = isIndirectlyReferenced;
            return isIndirectlyReferenced;
        }

        private IEnumerable<Type> ExtractOurTypes(Assembly assembly)
        {
            return assembly.GetTypes()
                           .Where(t => t.FullName != null
                                    && ExcludedTypes.All(mask => !t.FullName.Contains(mask, StringComparison.InvariantCulture)));
        }
    }
}