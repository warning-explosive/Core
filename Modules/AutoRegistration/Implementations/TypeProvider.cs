namespace SpaceEngineers.Core.AutoRegistration.Implementations
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Linq;
    using System.Reflection;
    using AutoWiring.Api.Attributes;
    using AutoWiring.Api.Enumerations;
    using AutoWiring.Api.Services;
    using Basics;
    using Basics.EqualityComparers;

    [SuppressMessage("Analysis", "CR1", Justification = "Registered by hand. See DependencyContainerImpl.")]
    [Component(EnLifestyle.Singleton, EnComponentRegistrationKind.ManuallyRegistered)]
    internal class TypeProvider : ITypeProvider
    {
        private static readonly string[] ExcludedTypes =
        {
            "<>f",
            "<>c",
            "d__",
            "<PrivateImplementationDetails>",
            "AutoGeneratedProgram",
            "Xunit",
            "System.Runtime.CompilerServices",
            "Microsoft.CodeAnalysis"
        };

        private readonly HashSet<string> _ourTypesCache;

        public TypeProvider(IReadOnlyCollection<Assembly> allAssemblies,
                            IReadOnlyCollection<Assembly> rootAssemblies,
                            IReadOnlyCollection<Assembly> excludedAssemblies,
                            IReadOnlyCollection<string> excludedNamespaces)
        {
            AllLoadedAssemblies = allAssemblies
                .Union(rootAssemblies)
                .Distinct(new AssemblyByNameEqualityComparer())
                .Where(a => !a.IsDynamic)
                .ToList();

            AllLoadedTypes = AllLoadedAssemblies
                .SelectMany(a => a.GetTypes())
                .ToList();

            TypeCache = AllLoadedAssemblies
                .ToDictionary(assembly => assembly.GetName().Name,
                    assembly => (IReadOnlyDictionary<string, Type>)assembly.GetTypes().ToDictionary(type => type.FullName));

            var isOurReference = AssembliesExtensions.IsOurReference(AllLoadedAssemblies, rootAssemblies);

            OurAssemblies = AllLoadedAssemblies
                .Where(a => !excludedAssemblies.Contains(a))
                .Where(isOurReference)
                .ToList();

            OurTypes = OurAssemblies
                .SelectMany(ExtractOurTypes)
                .Where(t => !excludedNamespaces.Contains(t.Namespace, StringComparer.OrdinalIgnoreCase))
                .ToList();

            _ourTypesCache = new HashSet<string>(OurTypes.Select(type => type.FullName));
        }

        public IReadOnlyCollection<Assembly> AllLoadedAssemblies { get; }

        public IReadOnlyCollection<Type> AllLoadedTypes { get; }

        public IReadOnlyCollection<Assembly> OurAssemblies { get; }

        public IReadOnlyCollection<Type> OurTypes { get; }

        public IReadOnlyDictionary<string, IReadOnlyDictionary<string, Type>> TypeCache { get; }

        public bool IsOurType(Type type)
        {
            return _ourTypesCache.Contains(type.FullName);
        }

        private static IEnumerable<Type> ExtractOurTypes(Assembly assembly)
        {
            return assembly
                .GetTypes()
                .Where(t => t.FullName != null
                            && ExcludedTypes.All(mask => !t.FullName.Contains(mask, StringComparison.Ordinal)));
        }
    }
}