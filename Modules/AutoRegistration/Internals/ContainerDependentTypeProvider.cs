namespace SpaceEngineers.Core.AutoRegistration.Internals
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Linq;
    using System.Reflection;
    using AutoWiringApi.Abstractions;
    using AutoWiringApi.Attributes;
    using AutoWiringApi.Enumerations;
    using Basics;
    using Basics.EqualityComparers;

    [Lifestyle(EnLifestyle.Singleton)]
    [ManualRegistration]
    internal class ContainerDependentTypeProvider : ITypeProvider
    {
        private static readonly string[] ExcludedAssemblies =
        {
            nameof(System),
            nameof(Microsoft),
            "Windows",
        };

        private static readonly string[] ExcludedTypes =
        {
            "<>f",
            "<>c",
            "<PrivateImplementationDetails>",
            "AutoGeneratedProgram",
            nameof(Microsoft),
            nameof(System),
            "Windows",
        };

        private readonly HashSet<string> _ourTypesCache;

        public ContainerDependentTypeProvider(Assembly[] assemblies, Assembly[] rootAssemblies)
        {
            AllLoadedAssemblies = assemblies.Where(a => !a.IsDynamic).ToList();
            AllLoadedTypes = AllLoadedAssemblies.SelectMany(a => a.GetTypes()).ToList();
            TypeCache = AllLoadedTypes
                       .GroupBy(type => type.Assembly.GetName().Name)
                       .ToDictionary(grp => grp.Key,
                                     grp => (IReadOnlyDictionary<string, Type>)grp.ToDictionary(type => type.FullName));

            var loadedAssembliesDict = AllLoadedAssemblies.Distinct(new AssemblyByNameEqualityComparer()).ToDictionary(a => a.GetName().FullName);
            var rootAssembliesDict = rootAssemblies.ToDictionary(a => a.GetName().FullName, a => a);
            var visited = rootAssemblies.ToDictionary(root => root.GetName().FullName, _ => true);

            OurAssemblies = loadedAssembliesDict
                           .Except(rootAssembliesDict)
                           .Select(pair => pair.Value)
                           .Where(a => IsOurReference(a, loadedAssembliesDict, visited))
                           .Concat(rootAssemblies)
                           .ToList();

            OurTypes = OurAssemblies
                      .SelectMany(ExtractOurTypes)
                      .ToList();

            _ourTypesCache = OurTypes.Select(type => type.FullName).ToHashSet();
        }

        public IReadOnlyCollection<Assembly> AllLoadedAssemblies { get; }

        public IReadOnlyCollection<Type> AllLoadedTypes { get; }

        public IReadOnlyCollection<Assembly> OurAssemblies { get; }

        public IReadOnlyCollection<Type> OurTypes { get; }

        public IReadOnlyDictionary<string, IReadOnlyDictionary<string, Type>> TypeCache { get; }

        public bool IsOurType(Type type)
        {
            return _ourTypesCache.Contains(type.FullName);
        }

        private bool IsOurReference(Assembly assembly, IReadOnlyDictionary<string, Assembly> loadedAssemblies, IDictionary<string, bool> visited)
        {
            var exclusiveReferences = assembly.GetReferencedAssemblies();
            var isReferencedDirectly = exclusiveReferences.Any(a => visited.ContainsKey(a.FullName) && visited[a.FullName]);
            var key = assembly.GetName().FullName;

            if (isReferencedDirectly)
            {
                visited[key] = true;
                return true;
            }

            var isIndirectlyReferenced = exclusiveReferences
                .Where(unknownReference => !visited.ContainsKey(unknownReference.FullName)
                                        && ExcludedAssemblies.All(ex => !unknownReference.FullName.StartsWith(ex, StringComparison.InvariantCultureIgnoreCase)))
                .Any(unknownReference => loadedAssemblies.TryGetValue(unknownReference.FullName, out var unknownAssembly)
                                         && IsOurReference(unknownAssembly, loadedAssemblies, visited));

            visited[key] = isIndirectlyReferenced;
            return isIndirectlyReferenced;
        }

        private IEnumerable<Type> ExtractOurTypes(Assembly assembly)
        {
            return assembly.GetTypes()
                           .Where(t => t.FullName != null
                                    && ExcludedTypes.All(mask => !t.FullName.Contains(mask)));
        }
    }
}